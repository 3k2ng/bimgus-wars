# CPSC 599.82 Assignment 2
Compression algorithm for game title screen.

## Uncompressed data
Uncompressed data are generated from `./data/make_bin.py` and `./data/title_image.png`, creating `./data/char_set.bin` containing custom character data, 
`./data/char_map.bin` containing screen character data, and `./data/color_map.bin` containing screen color data. These binary are then converted 
into assembly code using `./data/make_uncompressed.py`, and included in `./title_screen_uncompressed.s`.

`./title_screen_uncompressed.s` simply initialize the VIC-20 to use character from RAM position at `$1c00`, and set the background to black. Then the data are copied 
to appropriate region (character data to `$1c00`, screen data to `$1e00`, color data to `$9600`).

Size:
- `./data/char_set.bin`: 248 bytes
- `./data/char_map.bin`: 506 bytes
- `./data/color_map.bin`: 506 bytes
- `./export/_title_screen_uncompressed.prg`: 1399 bytes

## Hand-designed compressor
The hand-desgined compression algorithm is a LZW-inspired algorithm with a consideration for repeating data. Two custom characters are added `0x7f` and `0x7e`, 
`0x7f` to denote the end of the file, and `0x7e` to switch to back-reading mode. `0x7e` will be followed by 2 bytes `B` and `L`, 
`B` for the offset between the back-reading location and the current location on the destination, `L` for the number of bytes being read until we switch back to reading 
the files normally. `L` can be greater than `B`, this will cause the back-reader to read the bytes just written during back-reading.

The compression are done with `./data/umc.py` on `./data/char_map.bin` and `./data/color_map.bin` to create `./data/char_map.umc` and `./data/color_map.umc`, 
the compression cannot be done on `./data/char_set.bin` or rather the original data cannot be obtained from the compressed data, as `./data/char_set.bin` has `0x7f` and `0x7e`, 
leading to confusion during decompression. The data is then converted into an assembly source file to be included in `./title_screen_umc.s`.

Size comparision:
- `./data/char_set.bin` (Uncompressed): 248 bytes ~ 1:1 compression ratio
- `./data/char_map.umc`: 225 bytes ~ 2.24:1 compression ratio
- `./data/color_map.umc`: 31 bytes ~ 16.32:1 compression ratio
- `./export/_title_screen_umc.prg`: 672 bytes ~ 2.08:1 compression ratio

## General compressor
For the general decompressor, we used ZX02 compressor, along with their provided 6502 decompressor. There are tweaks needed to be made to the provided decompressor for it to work
with dasm. The provided file `zx02-optim.asm` is modified into `./title_screen_zx02.s` solely for decompressing our zx02 compressed data into the title screen data.
This includes `./data/char_set.bin`, `./data/char_map.bin` and `./data/color_map.bin`. The result data is then converted into an assembly source code file to be included 
in `./title_screen_zx02.s`.

Size comparision:
- `./data/char_set.zx02`: 138 bytes ~ 1.79:1 compression ratio
- `./data/char_map.zx02`: 165 bytes ~ 3.07:1 compression ratio
- `./data/color_map.zx02`: 24 bytes ~ 21.08:1 compression ratio
- `./export/_title_screen_zx02.prg`: 557 bytes ~ 2.51:1 compression ratio

## AI generated compressor
A compressor is generated by chatGPT given the circumstances, this compressor also take in the uncompressed binary files and create corresponding compressed binary files.
The result data is then converted into an assembly source code file to be included in `./title_screen_ai.s`.

Size comparision:
- `./data/char_set_rle.bin`: 274 bytes ~ 0.91:1 compression ratio
- `./data/char_map_rle.bin`: 380 bytes ~ 1.33:1 compression ratio
- `./data/color_map_rle.bin`: 34 bytes ~ 14.88:1 compression ratio
- `./export/_title_screen_ai.prg`: 836 bytes ~ 1.67:1 compression ratio

### Prompts used to generate the encoder files in Python
- https://chatgpt.com/share/6722e44d-d9e4-8004-b9be-2b2ebd7c1e3f
- https://chatgpt.com/share/6722e51e-6e38-8004-bf20-fe6098e14500

### Prompts used to generate the decoder in assembly:
- https://aiarchives.org/id/k8NA8sBhl1fLgq5i03Cv

### Manual modifications to AI generated Source Files
- Indenting: minor changes to the line indenting as well
as spacing were done to get the source files to run
- Decoder logic: in the assembly code decoder there is a branch that checks
if the count value is equal to `0x7f`. This caused problems with the Python encoder. Some of the code in the Python encoder had to be manually changed to account
for this.
